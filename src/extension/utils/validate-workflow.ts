/**
 * Workflow Validation Utility
 *
 * Validates AI-generated workflows against schema rules.
 * Based on: /specs/001-ai-workflow-generation/research.md Q3
 */

import {
  type Connection,
  type McpNodeData,
  NodeType,
  type SkillNodeData,
  type SwitchNodeData,
  VALIDATION_RULES,
  type Workflow,
  type WorkflowNode,
} from '../../shared/types/workflow-definition';

export interface ValidationError {
  code: string;
  message: string;
  field?: string;
}

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
}

/**
 * Validate a workflow generated by AI
 *
 * @param workflow - The workflow object to validate
 * @returns Validation result with errors if invalid
 */
export function validateAIGeneratedWorkflow(workflow: unknown): ValidationResult {
  const errors: ValidationError[] = [];

  // Type check: Is it an object?
  if (typeof workflow !== 'object' || workflow === null) {
    return {
      valid: false,
      errors: [{ code: 'INVALID_TYPE', message: 'Workflow must be an object' }],
    };
  }

  const wf = workflow as Partial<Workflow>;

  // Required fields check
  if (!wf.id || typeof wf.id !== 'string') {
    errors.push({ code: 'MISSING_FIELD', message: 'Workflow must have an id', field: 'id' });
  }

  if (!wf.name || typeof wf.name !== 'string') {
    errors.push({ code: 'MISSING_FIELD', message: 'Workflow must have a name', field: 'name' });
  }

  if (!wf.version || typeof wf.version !== 'string') {
    errors.push({
      code: 'MISSING_FIELD',
      message: 'Workflow must have a version',
      field: 'version',
    });
  } else if (!VALIDATION_RULES.WORKFLOW.VERSION_PATTERN.test(wf.version)) {
    errors.push({
      code: 'INVALID_FORMAT',
      message: 'Version must follow semantic versioning (e.g., 1.0.0)',
      field: 'version',
    });
  }

  if (!Array.isArray(wf.nodes)) {
    errors.push({
      code: 'MISSING_FIELD',
      message: 'Workflow must have a nodes array',
      field: 'nodes',
    });
    // Cannot continue validation without nodes
    return { valid: false, errors };
  }

  if (!Array.isArray(wf.connections)) {
    errors.push({
      code: 'MISSING_FIELD',
      message: 'Workflow must have a connections array',
      field: 'connections',
    });
  }

  // Node count validation
  if (wf.nodes.length > VALIDATION_RULES.WORKFLOW.MAX_NODES) {
    errors.push({
      code: 'MAX_NODES_EXCEEDED',
      message: `Generated workflow exceeds maximum node limit (${VALIDATION_RULES.WORKFLOW.MAX_NODES}). Please simplify your description.`,
      field: 'nodes',
    });
  }

  // Node-specific validation
  const nodeErrors = validateNodes(wf.nodes);
  errors.push(...nodeErrors);

  // Connection validation (only if connections array exists)
  if (Array.isArray(wf.connections)) {
    const connectionErrors = validateConnections(wf.connections, wf.nodes);
    errors.push(...connectionErrors);
  }

  // Start/End node validation
  const startNodes = wf.nodes.filter((n) => n.type === NodeType.Start);
  const endNodes = wf.nodes.filter((n) => n.type === NodeType.End);

  if (startNodes.length === 0) {
    errors.push({
      code: 'MISSING_START_NODE',
      message: 'Workflow must have at least one Start node',
    });
  }

  if (startNodes.length > 1) {
    errors.push({
      code: 'MULTIPLE_START_NODES',
      message: 'Workflow must have exactly one Start node',
    });
  }

  if (endNodes.length === 0) {
    errors.push({
      code: 'MISSING_END_NODE',
      message: 'Workflow must have at least one End node',
    });
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate all nodes in the workflow
 */
function validateNodes(nodes: WorkflowNode[]): ValidationError[] {
  const errors: ValidationError[] = [];
  const nodeIds = new Set<string>();

  for (const node of nodes) {
    // Check for duplicate IDs
    if (nodeIds.has(node.id)) {
      errors.push({
        code: 'DUPLICATE_NODE_ID',
        message: `Duplicate node ID: ${node.id}`,
        field: `nodes[${node.id}]`,
      });
    }
    nodeIds.add(node.id);

    // Validate node name
    if (!node.name || !VALIDATION_RULES.NODE.NAME_PATTERN.test(node.name)) {
      errors.push({
        code: 'INVALID_NODE_NAME',
        message: `Node name must match pattern ${VALIDATION_RULES.NODE.NAME_PATTERN}`,
        field: `nodes[${node.id}].name`,
      });
    }

    // Validate node type
    if (!Object.values(NodeType).includes(node.type)) {
      errors.push({
        code: 'INVALID_NODE_TYPE',
        message: `Invalid node type: ${node.type}`,
        field: `nodes[${node.id}].type`,
      });
    }

    // Validate position
    if (
      !node.position ||
      typeof node.position.x !== 'number' ||
      typeof node.position.y !== 'number'
    ) {
      errors.push({
        code: 'INVALID_POSITION',
        message: 'Node must have valid position with x and y coordinates',
        field: `nodes[${node.id}].position`,
      });
    }

    // Validate Skill nodes (T026)
    if (node.type === NodeType.Skill) {
      const skillErrors = validateSkillNode(node);
      errors.push(...skillErrors);
    }

    // Validate MCP nodes (T017)
    if (node.type === NodeType.Mcp) {
      const mcpErrors = validateMcpNode(node);
      errors.push(...mcpErrors);
    }

    // Validate Switch nodes
    if (node.type === NodeType.Switch) {
      const switchErrors = validateSwitchNode(node);
      errors.push(...switchErrors);
    }
  }

  return errors;
}

/**
 * Validate Switch node structure and default branch rules
 *
 * @param node - Switch node to validate
 * @returns Array of validation errors
 */
function validateSwitchNode(node: WorkflowNode): ValidationError[] {
  const errors: ValidationError[] = [];
  const switchData = node.data as Partial<SwitchNodeData>;

  if (!switchData.branches || !Array.isArray(switchData.branches)) {
    errors.push({
      code: 'SWITCH_MISSING_BRANCHES',
      message: 'Switch node must have branches array',
      field: `nodes[${node.id}].data.branches`,
    });
    return errors;
  }

  // Check for multiple default branches
  const defaultBranches = switchData.branches.filter((b) => b.isDefault);
  if (defaultBranches.length > 1) {
    errors.push({
      code: 'SWITCH_MULTIPLE_DEFAULT',
      message: 'Switch node can only have one default branch',
      field: `nodes[${node.id}].data.branches`,
    });
  }

  // Check that default branch is last (if it exists)
  if (defaultBranches.length === 1) {
    const lastBranch = switchData.branches[switchData.branches.length - 1];
    if (!lastBranch?.isDefault) {
      errors.push({
        code: 'SWITCH_DEFAULT_NOT_LAST',
        message: 'Default branch must be the last branch in Switch node',
        field: `nodes[${node.id}].data.branches`,
      });
    }
  }

  return errors;
}

/**
 * Validate Skill node structure and fields
 *
 * Based on: /specs/001-ai-skill-generation/contracts/skill-scanning-api.md Section 5.1
 *
 * @param node - Skill node to validate
 * @returns Array of validation errors (T024-T025)
 */
function validateSkillNode(node: WorkflowNode): ValidationError[] {
  const errors: ValidationError[] = [];
  const skillData = node.data as Partial<SkillNodeData>;

  // Required fields check
  const requiredFields: (keyof SkillNodeData)[] = [
    'name',
    'description',
    'skillPath',
    'scope',
    'validationStatus',
    'outputPorts',
  ];

  for (const field of requiredFields) {
    if (!skillData[field]) {
      errors.push({
        code: 'SKILL_MISSING_FIELD',
        message: `Skill node missing required field: ${field}`,
        field: `nodes[${node.id}].data.${field}`,
      });
    }
  }

  // Name validation
  if (skillData.name) {
    if (!VALIDATION_RULES.SKILL.NAME_PATTERN.test(skillData.name)) {
      errors.push({
        code: 'SKILL_INVALID_NAME',
        message: 'Skill name must be lowercase with hyphens only',
        field: `nodes[${node.id}].data.name`,
      });
    }

    if (skillData.name.length > VALIDATION_RULES.SKILL.NAME_MAX_LENGTH) {
      errors.push({
        code: 'SKILL_NAME_TOO_LONG',
        message: `Skill name exceeds ${VALIDATION_RULES.SKILL.NAME_MAX_LENGTH} characters`,
        field: `nodes[${node.id}].data.name`,
      });
    }
  }

  // Description validation
  if (skillData.description) {
    if (skillData.description.length > VALIDATION_RULES.SKILL.DESCRIPTION_MAX_LENGTH) {
      errors.push({
        code: 'SKILL_DESC_TOO_LONG',
        message: `Skill description exceeds ${VALIDATION_RULES.SKILL.DESCRIPTION_MAX_LENGTH} characters`,
        field: `nodes[${node.id}].data.description`,
      });
    }
  }

  // Output ports validation
  if (skillData.outputPorts !== VALIDATION_RULES.SKILL.OUTPUT_PORTS) {
    errors.push({
      code: 'SKILL_INVALID_PORTS',
      message:
        'Skill outputPorts must equal 1. For branching, use ifElse or switch nodes after the Skill node.',
      field: `nodes[${node.id}].data.outputPorts`,
    });
  }

  return errors;
}

/**
 * Validate MCP node structure and fields
 *
 * Based on: contracts/workflow-mcp-node.schema.json
 *
 * @param node - MCP node to validate
 * @returns Array of validation errors (T017)
 */
function validateMcpNode(node: WorkflowNode): ValidationError[] {
  const errors: ValidationError[] = [];
  const mcpData = node.data as Partial<McpNodeData>;

  // Common required fields (all modes)
  const commonRequiredFields: (keyof McpNodeData)[] = [
    'serverId',
    'validationStatus',
    'outputPorts',
  ];

  for (const field of commonRequiredFields) {
    const value = mcpData[field as keyof typeof mcpData];
    if (value === undefined || value === null || value === '') {
      errors.push({
        code: 'MCP_MISSING_FIELD',
        message: `MCP node missing required field: ${field}`,
        field: `nodes[${node.id}].data.${field}`,
      });
    }
  }

  // Server ID validation
  if (mcpData.serverId) {
    if (mcpData.serverId.length < VALIDATION_RULES.MCP.SERVER_ID_MIN_LENGTH) {
      errors.push({
        code: 'MCP_INVALID_SERVER_ID',
        message: `MCP server ID too short (min ${VALIDATION_RULES.MCP.SERVER_ID_MIN_LENGTH} characters)`,
        field: `nodes[${node.id}].data.serverId`,
      });
    }

    if (mcpData.serverId.length > VALIDATION_RULES.MCP.SERVER_ID_MAX_LENGTH) {
      errors.push({
        code: 'MCP_SERVER_ID_TOO_LONG',
        message: `MCP server ID exceeds ${VALIDATION_RULES.MCP.SERVER_ID_MAX_LENGTH} characters`,
        field: `nodes[${node.id}].data.serverId`,
      });
    }
  }

  // Tool name validation
  if (mcpData.toolName) {
    if (mcpData.toolName.length < VALIDATION_RULES.MCP.TOOL_NAME_MIN_LENGTH) {
      errors.push({
        code: 'MCP_INVALID_TOOL_NAME',
        message: `MCP tool name too short (min ${VALIDATION_RULES.MCP.TOOL_NAME_MIN_LENGTH} characters)`,
        field: `nodes[${node.id}].data.toolName`,
      });
    }

    if (mcpData.toolName.length > VALIDATION_RULES.MCP.TOOL_NAME_MAX_LENGTH) {
      errors.push({
        code: 'MCP_TOOL_NAME_TOO_LONG',
        message: `MCP tool name exceeds ${VALIDATION_RULES.MCP.TOOL_NAME_MAX_LENGTH} characters`,
        field: `nodes[${node.id}].data.toolName`,
      });
    }
  }

  // Tool description validation
  if (
    mcpData.toolDescription &&
    mcpData.toolDescription.length > VALIDATION_RULES.MCP.TOOL_DESCRIPTION_MAX_LENGTH
  ) {
    errors.push({
      code: 'MCP_TOOL_DESC_TOO_LONG',
      message: `MCP tool description exceeds ${VALIDATION_RULES.MCP.TOOL_DESCRIPTION_MAX_LENGTH} characters`,
      field: `nodes[${node.id}].data.toolDescription`,
    });
  }

  // Parameters array validation
  if (mcpData.parameters) {
    if (!Array.isArray(mcpData.parameters)) {
      errors.push({
        code: 'MCP_INVALID_PARAMETERS',
        message: 'MCP parameters must be an array',
        field: `nodes[${node.id}].data.parameters`,
      });
    }
  }

  // Parameter values validation
  if (mcpData.parameterValues) {
    if (
      typeof mcpData.parameterValues !== 'object' ||
      mcpData.parameterValues === null ||
      Array.isArray(mcpData.parameterValues)
    ) {
      errors.push({
        code: 'MCP_INVALID_PARAMETER_VALUES',
        message: 'MCP parameterValues must be an object',
        field: `nodes[${node.id}].data.parameterValues`,
      });
    }
  }

  // Validation status check
  if (mcpData.validationStatus) {
    const validStatuses = ['valid', 'missing', 'invalid'];
    if (!validStatuses.includes(mcpData.validationStatus)) {
      errors.push({
        code: 'MCP_INVALID_STATUS',
        message: `MCP validationStatus must be one of: ${validStatuses.join(', ')}`,
        field: `nodes[${node.id}].data.validationStatus`,
      });
    }
  }

  // Output ports validation
  if (mcpData.outputPorts !== VALIDATION_RULES.MCP.OUTPUT_PORTS) {
    errors.push({
      code: 'MCP_INVALID_PORTS',
      message:
        'MCP outputPorts must equal 1. For branching, use ifElse or switch nodes after the MCP node.',
      field: `nodes[${node.id}].data.outputPorts`,
    });
  }

  // Mode-specific configuration validation (T058)
  const mode = mcpData.mode || 'manualParameterConfig';

  switch (mode) {
    case 'manualParameterConfig':
      // Manual mode requires toolName, toolDescription, parameters, parameterValues
      if (!mcpData.toolName || mcpData.toolName.trim().length === 0) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'Manual parameter config mode requires toolName to be set',
          field: `nodes[${node.id}].data.toolName`,
        });
      }
      if (!mcpData.toolDescription || mcpData.toolDescription.trim().length === 0) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'Manual parameter config mode requires toolDescription to be set',
          field: `nodes[${node.id}].data.toolDescription`,
        });
      }
      // parameters配列が定義されていない場合のみエラー（空配列はOK - パラメータなしツール用）
      if (!mcpData.parameters) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'Manual parameter config mode requires parameters array to be set',
          field: `nodes[${node.id}].data.parameters`,
        });
      }
      // parametersが空でない場合のみ、parameterValuesの存在をチェック
      if (mcpData.parameters && mcpData.parameters.length > 0) {
        if (!mcpData.parameterValues || Object.keys(mcpData.parameterValues).length === 0) {
          errors.push({
            code: 'MCP_MODE_CONFIG_MISMATCH',
            message: 'Manual parameter config mode requires parameterValues to be configured',
            field: `nodes[${node.id}].data.parameterValues`,
          });
        }
      }
      break;

    case 'aiParameterConfig':
      // AI parameter config mode requires toolName, toolDescription, parameters, aiParameterConfig
      if (!mcpData.toolName || mcpData.toolName.trim().length === 0) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'AI parameter config mode requires toolName to be set',
          field: `nodes[${node.id}].data.toolName`,
        });
      }
      if (!mcpData.toolDescription || mcpData.toolDescription.trim().length === 0) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'AI parameter config mode requires toolDescription to be set',
          field: `nodes[${node.id}].data.toolDescription`,
        });
      }
      if (!mcpData.parameters || mcpData.parameters.length === 0) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'AI parameter config mode requires parameters array to be set',
          field: `nodes[${node.id}].data.parameters`,
        });
      }
      if (!mcpData.aiParameterConfig) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'AI parameter config mode requires aiParameterConfig to be set',
          field: `nodes[${node.id}].data.aiParameterConfig`,
        });
      } else if (
        !mcpData.aiParameterConfig.description ||
        mcpData.aiParameterConfig.description.trim().length === 0
      ) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message:
            'AI parameter config mode requires aiParameterConfig.description to be non-empty',
          field: `nodes[${node.id}].data.aiParameterConfig.description`,
        });
      }
      // parameterValues is optional (AI will set values based on description)
      break;

    case 'aiToolSelection':
      // AI tool selection mode requires aiToolSelectionConfig
      if (!mcpData.aiToolSelectionConfig) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'AI tool selection mode requires aiToolSelectionConfig to be set',
          field: `nodes[${node.id}].data.aiToolSelectionConfig`,
        });
      } else if (
        !mcpData.aiToolSelectionConfig.taskDescription ||
        mcpData.aiToolSelectionConfig.taskDescription.trim().length === 0
      ) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message:
            'AI tool selection mode requires aiToolSelectionConfig.taskDescription to be non-empty',
          field: `nodes[${node.id}].data.aiToolSelectionConfig.taskDescription`,
        });
      }
      // toolName is optional for AI tool selection mode (AI will select the tool)
      break;

    default:
      // Unknown mode
      errors.push({
        code: 'MCP_INVALID_MODE',
        message: `Invalid MCP mode: ${mode}. Must be one of: manualParameterConfig, aiParameterConfig, aiToolSelection`,
        field: `nodes[${node.id}].data.mode`,
      });
  }

  return errors;
}

/**
 * Validate all connections in the workflow
 */
function validateConnections(connections: Connection[], nodes: WorkflowNode[]): ValidationError[] {
  const errors: ValidationError[] = [];
  const nodeIds = new Set(nodes.map((n) => n.id));
  const connectionIds = new Set<string>();

  for (const conn of connections) {
    // Check for duplicate connection IDs
    if (connectionIds.has(conn.id)) {
      errors.push({
        code: 'DUPLICATE_CONNECTION_ID',
        message: `Duplicate connection ID: ${conn.id}`,
        field: `connections[${conn.id}]`,
      });
    }
    connectionIds.add(conn.id);

    // Validate from/to node IDs exist
    if (!nodeIds.has(conn.from)) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: `Connection references non-existent from node: ${conn.from}`,
        field: `connections[${conn.id}].from`,
      });
    }

    if (!nodeIds.has(conn.to)) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: `Connection references non-existent to node: ${conn.to}`,
        field: `connections[${conn.id}].to`,
      });
    }

    // Validate no self-connections
    if (conn.from === conn.to) {
      errors.push({
        code: 'SELF_CONNECTION',
        message: 'Node cannot connect to itself',
        field: `connections[${conn.id}]`,
      });
    }

    // Validate Start/End node connection rules
    const fromNode = nodes.find((n) => n.id === conn.from);
    const toNode = nodes.find((n) => n.id === conn.to);

    if (toNode?.type === NodeType.Start) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: 'Start node cannot have input connections',
        field: `connections[${conn.id}]`,
      });
    }

    if (fromNode?.type === NodeType.End) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: 'End node cannot have output connections',
        field: `connections[${conn.id}]`,
      });
    }
  }

  // Check for cycles (simplified check - full cycle detection would be more complex)
  // For MVP, we'll rely on the AI to generate acyclic workflows

  return errors;
}
