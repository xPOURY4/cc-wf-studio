/**
 * Workflow Validation Utility
 *
 * Validates AI-generated workflows against schema rules.
 * Based on: /specs/001-ai-workflow-generation/research.md Q3
 */

import {
  type Connection,
  type HookType,
  type McpNodeData,
  NodeType,
  type SkillNodeData,
  type SubAgentFlow,
  type SubAgentFlowNodeData,
  type SwitchNodeData,
  VALIDATION_RULES,
  type Workflow,
  type WorkflowHooks,
  type WorkflowNode,
} from '../../shared/types/workflow-definition';

export interface ValidationError {
  code: string;
  message: string;
  field?: string;
}

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
}

/**
 * Validate a workflow generated by AI
 *
 * @param workflow - The workflow object to validate
 * @returns Validation result with errors if invalid
 */
export function validateAIGeneratedWorkflow(workflow: unknown): ValidationResult {
  const errors: ValidationError[] = [];

  // Type check: Is it an object?
  if (typeof workflow !== 'object' || workflow === null) {
    return {
      valid: false,
      errors: [{ code: 'INVALID_TYPE', message: 'Workflow must be an object' }],
    };
  }

  const wf = workflow as Partial<Workflow>;

  // Required fields check
  if (!wf.id || typeof wf.id !== 'string') {
    errors.push({ code: 'MISSING_FIELD', message: 'Workflow must have an id', field: 'id' });
  }

  if (!wf.name || typeof wf.name !== 'string') {
    errors.push({ code: 'MISSING_FIELD', message: 'Workflow must have a name', field: 'name' });
  } else if (!VALIDATION_RULES.WORKFLOW.NAME_PATTERN.test(wf.name)) {
    errors.push({
      code: 'INVALID_FORMAT',
      message:
        'Workflow name must contain only lowercase letters (a-z), numbers, hyphens, and underscores',
      field: 'name',
    });
  }

  if (!wf.version || typeof wf.version !== 'string') {
    errors.push({
      code: 'MISSING_FIELD',
      message: 'Workflow must have a version',
      field: 'version',
    });
  } else if (!VALIDATION_RULES.WORKFLOW.VERSION_PATTERN.test(wf.version)) {
    errors.push({
      code: 'INVALID_FORMAT',
      message: 'Version must follow semantic versioning (e.g., 1.0.0)',
      field: 'version',
    });
  }

  if (!Array.isArray(wf.nodes)) {
    errors.push({
      code: 'MISSING_FIELD',
      message: 'Workflow must have a nodes array',
      field: 'nodes',
    });
    // Cannot continue validation without nodes
    return { valid: false, errors };
  }

  if (!Array.isArray(wf.connections)) {
    errors.push({
      code: 'MISSING_FIELD',
      message: 'Workflow must have a connections array',
      field: 'connections',
    });
  }

  // Node count validation
  if (wf.nodes.length > VALIDATION_RULES.WORKFLOW.MAX_NODES) {
    errors.push({
      code: 'MAX_NODES_EXCEEDED',
      message: `Generated workflow exceeds maximum node limit (${VALIDATION_RULES.WORKFLOW.MAX_NODES}). Please simplify your description.`,
      field: 'nodes',
    });
  }

  // Node-specific validation
  const nodeErrors = validateNodes(wf.nodes);
  errors.push(...nodeErrors);

  // Connection validation (only if connections array exists)
  if (Array.isArray(wf.connections)) {
    const connectionErrors = validateConnections(wf.connections, wf.nodes);
    errors.push(...connectionErrors);
  }

  // Start/End node validation
  const startNodes = wf.nodes.filter((n) => n.type === NodeType.Start);
  const endNodes = wf.nodes.filter((n) => n.type === NodeType.End);

  if (startNodes.length === 0) {
    errors.push({
      code: 'MISSING_START_NODE',
      message: 'Workflow must have at least one Start node',
    });
  }

  if (startNodes.length > 1) {
    errors.push({
      code: 'MULTIPLE_START_NODES',
      message: 'Workflow must have exactly one Start node',
    });
  }

  if (endNodes.length === 0) {
    errors.push({
      code: 'MISSING_END_NODE',
      message: 'Workflow must have at least one End node',
    });
  }

  // SubAgentFlow reference validation
  const subAgentFlowErrors = validateSubAgentFlowReferences(wf as Workflow);
  errors.push(...subAgentFlowErrors);

  // Issue #413: Hooks validation
  if (wf.hooks) {
    const hooksErrors = validateHooks(wf.hooks);
    errors.push(...hooksErrors);
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate SubAgentFlow references in workflow
 *
 * Ensures all subAgentFlow nodes have corresponding SubAgentFlow definitions
 * and all SubAgentFlow definitions are valid.
 *
 * @param workflow - Workflow to validate
 * @returns Array of validation errors
 */
function validateSubAgentFlowReferences(workflow: Workflow): ValidationError[] {
  const errors: ValidationError[] = [];

  const subAgentFlowNodes = workflow.nodes.filter((n) => n.type === NodeType.SubAgentFlow);

  if (subAgentFlowNodes.length === 0) {
    return errors; // No SubAgentFlow nodes, nothing to validate
  }

  const subAgentFlowIds = new Set((workflow.subAgentFlows || []).map((sf) => sf.id));

  // Check each subAgentFlow node has a corresponding definition
  for (const node of subAgentFlowNodes) {
    const refData = node.data as SubAgentFlowNodeData;

    if (!subAgentFlowIds.has(refData.subAgentFlowId)) {
      errors.push({
        code: 'SUBAGENTFLOW_MISSING_DEFINITION',
        message: `SubAgentFlow node "${node.id}" references non-existent SubAgentFlow "${refData.subAgentFlowId}"`,
        field: `nodes[${node.id}].data.subAgentFlowId`,
      });
    }
  }

  // Validate each SubAgentFlow definition
  for (const subAgentFlow of workflow.subAgentFlows || []) {
    const subAgentFlowErrors = validateSubAgentFlow(subAgentFlow);
    errors.push(...subAgentFlowErrors);
  }

  return errors;
}

/**
 * Validate all nodes in the workflow
 */
function validateNodes(nodes: WorkflowNode[]): ValidationError[] {
  const errors: ValidationError[] = [];
  const nodeIds = new Set<string>();

  for (const node of nodes) {
    // Check for duplicate IDs
    if (nodeIds.has(node.id)) {
      errors.push({
        code: 'DUPLICATE_NODE_ID',
        message: `Duplicate node ID: ${node.id}`,
        field: `nodes[${node.id}]`,
      });
    }
    nodeIds.add(node.id);

    // Validate node name
    if (!node.name || !VALIDATION_RULES.NODE.NAME_PATTERN.test(node.name)) {
      errors.push({
        code: 'INVALID_NODE_NAME',
        message: `Node name must match pattern ${VALIDATION_RULES.NODE.NAME_PATTERN}`,
        field: `nodes[${node.id}].name`,
      });
    }

    // Validate node type
    if (!Object.values(NodeType).includes(node.type)) {
      errors.push({
        code: 'INVALID_NODE_TYPE',
        message: `Invalid node type: ${node.type}`,
        field: `nodes[${node.id}].type`,
      });
    }

    // Validate position
    if (
      !node.position ||
      typeof node.position.x !== 'number' ||
      typeof node.position.y !== 'number'
    ) {
      errors.push({
        code: 'INVALID_POSITION',
        message: 'Node must have valid position with x and y coordinates',
        field: `nodes[${node.id}].position`,
      });
    }

    // Validate Skill nodes (T026)
    if (node.type === NodeType.Skill) {
      const skillErrors = validateSkillNode(node);
      errors.push(...skillErrors);
    }

    // Validate MCP nodes (T017)
    if (node.type === NodeType.Mcp) {
      const mcpErrors = validateMcpNode(node);
      errors.push(...mcpErrors);
    }

    // Validate Switch nodes
    if (node.type === NodeType.Switch) {
      const switchErrors = validateSwitchNode(node);
      errors.push(...switchErrors);
    }

    // Validate SubAgentFlow nodes (Feature: 089-subworkflow)
    if (node.type === NodeType.SubAgentFlow) {
      const subAgentFlowErrors = validateSubAgentFlowNode(node);
      errors.push(...subAgentFlowErrors);
    }

    // Validate SubAgent memory enum (Feature: 540-persistent-memory)
    if (node.type === NodeType.SubAgent) {
      const subAgentData = node.data as { memory?: string };
      if (subAgentData.memory !== undefined) {
        const validMemoryScopes = ['user', 'project', 'local'];
        if (!validMemoryScopes.includes(subAgentData.memory)) {
          errors.push({
            code: 'SUBAGENT_INVALID_MEMORY',
            message: `SubAgent memory must be one of: ${validMemoryScopes.join(', ')}`,
            field: `nodes[${node.id}].data.memory`,
          });
        }
      }
    }
  }

  return errors;
}

/**
 * Validate Switch node structure and default branch rules
 *
 * @param node - Switch node to validate
 * @returns Array of validation errors
 */
function validateSwitchNode(node: WorkflowNode): ValidationError[] {
  const errors: ValidationError[] = [];
  const switchData = node.data as Partial<SwitchNodeData>;

  if (!switchData.branches || !Array.isArray(switchData.branches)) {
    errors.push({
      code: 'SWITCH_MISSING_BRANCHES',
      message: 'Switch node must have branches array',
      field: `nodes[${node.id}].data.branches`,
    });
    return errors;
  }

  // Check for multiple default branches
  const defaultBranches = switchData.branches.filter((b) => b.isDefault);
  if (defaultBranches.length > 1) {
    errors.push({
      code: 'SWITCH_MULTIPLE_DEFAULT',
      message: 'Switch node can only have one default branch',
      field: `nodes[${node.id}].data.branches`,
    });
  }

  // Check that default branch is last (if it exists)
  if (defaultBranches.length === 1) {
    const lastBranch = switchData.branches[switchData.branches.length - 1];
    if (!lastBranch?.isDefault) {
      errors.push({
        code: 'SWITCH_DEFAULT_NOT_LAST',
        message: 'Default branch must be the last branch in Switch node',
        field: `nodes[${node.id}].data.branches`,
      });
    }
  }

  return errors;
}

/**
 * Validate SubAgentFlow node structure and fields
 *
 * Feature: 089-subworkflow
 *
 * @param node - SubAgentFlow node to validate
 * @returns Array of validation errors
 */
function validateSubAgentFlowNode(node: WorkflowNode): ValidationError[] {
  const errors: ValidationError[] = [];
  const refData = node.data as Partial<SubAgentFlowNodeData>;

  // Required field: subAgentFlowId
  if (!refData.subAgentFlowId || typeof refData.subAgentFlowId !== 'string') {
    errors.push({
      code: 'SUBAGENTFLOW_MISSING_REF_ID',
      message: 'SubAgentFlow node must have a subAgentFlowId',
      field: `nodes[${node.id}].data.subAgentFlowId`,
    });
  }

  // Required field: label
  if (!refData.label || typeof refData.label !== 'string') {
    errors.push({
      code: 'SUBAGENTFLOW_MISSING_LABEL',
      message: 'SubAgentFlow node must have a label',
      field: `nodes[${node.id}].data.label`,
    });
  }

  // Output ports validation
  if (refData.outputPorts !== VALIDATION_RULES.SUB_AGENT_FLOW.OUTPUT_PORTS) {
    errors.push({
      code: 'SUBAGENTFLOW_INVALID_PORTS',
      message: 'SubAgentFlow outputPorts must equal 1',
      field: `nodes[${node.id}].data.outputPorts`,
    });
  }

  // Memory enum validation
  if (refData.memory !== undefined) {
    const validMemoryScopes = ['user', 'project', 'local'];
    if (!validMemoryScopes.includes(refData.memory)) {
      errors.push({
        code: 'SUBAGENTFLOW_INVALID_MEMORY',
        message: `SubAgentFlow memory must be one of: ${validMemoryScopes.join(', ')}`,
        field: `nodes[${node.id}].data.memory`,
      });
    }
  }

  return errors;
}

/**
 * Validate SubAgentFlow structure (for use within a workflow)
 *
 * Feature: 089-subworkflow
 * MVP constraints:
 * - No SubAgent nodes allowed
 * - No nested SubAgentFlowRef nodes allowed
 * - Must have exactly one Start node and at least one End node
 *
 * @param subAgentFlow - SubAgentFlow to validate
 * @returns Array of validation errors
 */
export function validateSubAgentFlow(subAgentFlow: SubAgentFlow): ValidationError[] {
  const errors: ValidationError[] = [];

  // Required fields
  if (!subAgentFlow.id) {
    errors.push({
      code: 'SUBAGENTFLOW_MISSING_ID',
      message: 'SubAgentFlow must have an id',
      field: 'id',
    });
  }

  if (!subAgentFlow.name) {
    errors.push({
      code: 'SUBAGENTFLOW_MISSING_NAME',
      message: 'SubAgentFlow must have a name',
      field: 'name',
    });
  }

  if (!Array.isArray(subAgentFlow.nodes)) {
    errors.push({
      code: 'SUBAGENTFLOW_MISSING_NODES',
      message: 'SubAgentFlow must have a nodes array',
      field: 'nodes',
    });
    return errors;
  }

  // Start/End node validation
  const startNodes = subAgentFlow.nodes.filter((n) => n.type === NodeType.Start);
  const endNodes = subAgentFlow.nodes.filter((n) => n.type === NodeType.End);

  if (startNodes.length === 0) {
    errors.push({
      code: 'SUBAGENTFLOW_INVALID_START',
      message: `SubAgentFlow "${subAgentFlow.name}" must have a Start node`,
    });
  }

  if (startNodes.length > 1) {
    errors.push({
      code: 'SUBAGENTFLOW_MULTIPLE_START',
      message: `SubAgentFlow "${subAgentFlow.name}" must have exactly one Start node`,
    });
  }

  if (endNodes.length === 0) {
    errors.push({
      code: 'SUBAGENTFLOW_MISSING_END',
      message: `SubAgentFlow "${subAgentFlow.name}" must have at least one End node`,
    });
  }

  // MVP constraint: No SubAgent nodes in SubAgentFlows
  const subAgentNodes = subAgentFlow.nodes.filter((n) => n.type === NodeType.SubAgent);
  if (subAgentNodes.length > 0) {
    errors.push({
      code: 'SUBAGENTFLOW_CONTAINS_SUBAGENT',
      message: `SubAgentFlow "${subAgentFlow.name}" cannot contain SubAgent nodes (MVP constraint)`,
    });
  }

  // MVP constraint: No nested SubAgentFlow nodes
  const nestedRefs = subAgentFlow.nodes.filter((n) => n.type === NodeType.SubAgentFlow);
  if (nestedRefs.length > 0) {
    errors.push({
      code: 'SUBAGENTFLOW_NESTED_REF',
      message: `SubAgentFlow "${subAgentFlow.name}" cannot contain SubAgentFlow nodes (no nesting allowed in MVP)`,
    });
  }

  return errors;
}

/**
 * Validate Skill node structure and fields
 *
 * Based on: /specs/001-ai-skill-generation/contracts/skill-scanning-api.md Section 5.1
 *
 * @param node - Skill node to validate
 * @returns Array of validation errors (T024-T025)
 */
function validateSkillNode(node: WorkflowNode): ValidationError[] {
  const errors: ValidationError[] = [];
  const skillData = node.data as Partial<SkillNodeData>;

  // Required fields check
  // Note: skillPath is optional when validationStatus is 'missing' (skill not found)
  const requiredFields: (keyof SkillNodeData)[] = [
    'name',
    'description',
    'scope',
    'validationStatus',
    'outputPorts',
  ];

  for (const field of requiredFields) {
    if (!skillData[field]) {
      errors.push({
        code: 'SKILL_MISSING_FIELD',
        message: `Skill node missing required field: ${field}`,
        field: `nodes[${node.id}].data.${field}`,
      });
    }
  }

  // skillPath is required only when skill is valid (not missing)
  if (skillData.validationStatus !== 'missing' && !skillData.skillPath) {
    errors.push({
      code: 'SKILL_MISSING_FIELD',
      message: 'Skill node missing required field: skillPath',
      field: `nodes[${node.id}].data.skillPath`,
    });
  }

  // Name validation
  if (skillData.name) {
    if (!VALIDATION_RULES.SKILL.NAME_PATTERN.test(skillData.name)) {
      errors.push({
        code: 'SKILL_INVALID_NAME',
        message: 'Skill name must be lowercase with hyphens only',
        field: `nodes[${node.id}].data.name`,
      });
    }

    if (skillData.name.length > VALIDATION_RULES.SKILL.NAME_MAX_LENGTH) {
      errors.push({
        code: 'SKILL_NAME_TOO_LONG',
        message: `Skill name exceeds ${VALIDATION_RULES.SKILL.NAME_MAX_LENGTH} characters`,
        field: `nodes[${node.id}].data.name`,
      });
    }
  }

  // Description validation
  if (skillData.description) {
    if (skillData.description.length > VALIDATION_RULES.SKILL.DESCRIPTION_MAX_LENGTH) {
      errors.push({
        code: 'SKILL_DESC_TOO_LONG',
        message: `Skill description exceeds ${VALIDATION_RULES.SKILL.DESCRIPTION_MAX_LENGTH} characters`,
        field: `nodes[${node.id}].data.description`,
      });
    }
  }

  // Output ports validation
  if (skillData.outputPorts !== VALIDATION_RULES.SKILL.OUTPUT_PORTS) {
    errors.push({
      code: 'SKILL_INVALID_PORTS',
      message:
        'Skill outputPorts must equal 1. For branching, use ifElse or switch nodes after the Skill node.',
      field: `nodes[${node.id}].data.outputPorts`,
    });
  }

  // Execution mode validation
  if (skillData.executionMode !== undefined) {
    const validModes = ['load', 'execute'];
    if (!validModes.includes(skillData.executionMode)) {
      errors.push({
        code: 'SKILL_INVALID_EXECUTION_MODE',
        message: `Skill executionMode must be one of: ${validModes.join(', ')}`,
        field: `nodes[${node.id}].data.executionMode`,
      });
    }
  }

  // Execution prompt length validation
  if (skillData.executionPrompt) {
    if (skillData.executionPrompt.length > VALIDATION_RULES.SKILL.EXECUTION_PROMPT_MAX_LENGTH) {
      errors.push({
        code: 'SKILL_EXECUTION_PROMPT_TOO_LONG',
        message: `Skill executionPrompt exceeds ${VALIDATION_RULES.SKILL.EXECUTION_PROMPT_MAX_LENGTH} characters`,
        field: `nodes[${node.id}].data.executionPrompt`,
      });
    }
  }

  return errors;
}

/**
 * Validate MCP node structure and fields
 *
 * Based on: contracts/workflow-mcp-node.schema.json
 *
 * @param node - MCP node to validate
 * @returns Array of validation errors (T017)
 */
function validateMcpNode(node: WorkflowNode): ValidationError[] {
  const errors: ValidationError[] = [];
  const mcpData = node.data as Partial<McpNodeData>;

  // Common required fields (all modes)
  const commonRequiredFields: (keyof McpNodeData)[] = [
    'serverId',
    'validationStatus',
    'outputPorts',
  ];

  for (const field of commonRequiredFields) {
    const value = mcpData[field as keyof typeof mcpData];
    if (value === undefined || value === null || value === '') {
      errors.push({
        code: 'MCP_MISSING_FIELD',
        message: `MCP node missing required field: ${field}`,
        field: `nodes[${node.id}].data.${field}`,
      });
    }
  }

  // Server ID validation
  if (mcpData.serverId) {
    if (mcpData.serverId.length < VALIDATION_RULES.MCP.SERVER_ID_MIN_LENGTH) {
      errors.push({
        code: 'MCP_INVALID_SERVER_ID',
        message: `MCP server ID too short (min ${VALIDATION_RULES.MCP.SERVER_ID_MIN_LENGTH} characters)`,
        field: `nodes[${node.id}].data.serverId`,
      });
    }

    if (mcpData.serverId.length > VALIDATION_RULES.MCP.SERVER_ID_MAX_LENGTH) {
      errors.push({
        code: 'MCP_SERVER_ID_TOO_LONG',
        message: `MCP server ID exceeds ${VALIDATION_RULES.MCP.SERVER_ID_MAX_LENGTH} characters`,
        field: `nodes[${node.id}].data.serverId`,
      });
    }
  }

  // Tool name validation
  if (mcpData.toolName) {
    if (mcpData.toolName.length < VALIDATION_RULES.MCP.TOOL_NAME_MIN_LENGTH) {
      errors.push({
        code: 'MCP_INVALID_TOOL_NAME',
        message: `MCP tool name too short (min ${VALIDATION_RULES.MCP.TOOL_NAME_MIN_LENGTH} characters)`,
        field: `nodes[${node.id}].data.toolName`,
      });
    }

    if (mcpData.toolName.length > VALIDATION_RULES.MCP.TOOL_NAME_MAX_LENGTH) {
      errors.push({
        code: 'MCP_TOOL_NAME_TOO_LONG',
        message: `MCP tool name exceeds ${VALIDATION_RULES.MCP.TOOL_NAME_MAX_LENGTH} characters`,
        field: `nodes[${node.id}].data.toolName`,
      });
    }
  }

  // Tool description validation
  if (
    mcpData.toolDescription &&
    mcpData.toolDescription.length > VALIDATION_RULES.MCP.TOOL_DESCRIPTION_MAX_LENGTH
  ) {
    errors.push({
      code: 'MCP_TOOL_DESC_TOO_LONG',
      message: `MCP tool description exceeds ${VALIDATION_RULES.MCP.TOOL_DESCRIPTION_MAX_LENGTH} characters`,
      field: `nodes[${node.id}].data.toolDescription`,
    });
  }

  // Parameters array validation
  if (mcpData.parameters) {
    if (!Array.isArray(mcpData.parameters)) {
      errors.push({
        code: 'MCP_INVALID_PARAMETERS',
        message: 'MCP parameters must be an array',
        field: `nodes[${node.id}].data.parameters`,
      });
    }
  }

  // Parameter values validation
  if (mcpData.parameterValues) {
    if (
      typeof mcpData.parameterValues !== 'object' ||
      mcpData.parameterValues === null ||
      Array.isArray(mcpData.parameterValues)
    ) {
      errors.push({
        code: 'MCP_INVALID_PARAMETER_VALUES',
        message: 'MCP parameterValues must be an object',
        field: `nodes[${node.id}].data.parameterValues`,
      });
    }
  }

  // Validation status check
  if (mcpData.validationStatus) {
    const validStatuses = ['valid', 'missing', 'invalid'];
    if (!validStatuses.includes(mcpData.validationStatus)) {
      errors.push({
        code: 'MCP_INVALID_STATUS',
        message: `MCP validationStatus must be one of: ${validStatuses.join(', ')}`,
        field: `nodes[${node.id}].data.validationStatus`,
      });
    }
  }

  // Output ports validation
  if (mcpData.outputPorts !== VALIDATION_RULES.MCP.OUTPUT_PORTS) {
    errors.push({
      code: 'MCP_INVALID_PORTS',
      message:
        'MCP outputPorts must equal 1. For branching, use ifElse or switch nodes after the MCP node.',
      field: `nodes[${node.id}].data.outputPorts`,
    });
  }

  // Mode-specific configuration validation (T058)
  const mode = mcpData.mode || 'manualParameterConfig';

  switch (mode) {
    case 'manualParameterConfig':
      // Manual mode requires toolName, toolDescription, parameters, parameterValues
      if (!mcpData.toolName || mcpData.toolName.trim().length === 0) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'Manual parameter config mode requires toolName to be set',
          field: `nodes[${node.id}].data.toolName`,
        });
      }
      if (!mcpData.toolDescription || mcpData.toolDescription.trim().length === 0) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'Manual parameter config mode requires toolDescription to be set',
          field: `nodes[${node.id}].data.toolDescription`,
        });
      }
      // parameters配列が定義されていない場合のみエラー（空配列はOK - パラメータなしツール用）
      if (!mcpData.parameters) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'Manual parameter config mode requires parameters array to be set',
          field: `nodes[${node.id}].data.parameters`,
        });
      }
      // parametersが空でない場合のみ、parameterValuesの存在をチェック
      if (mcpData.parameters && mcpData.parameters.length > 0) {
        if (!mcpData.parameterValues || Object.keys(mcpData.parameterValues).length === 0) {
          errors.push({
            code: 'MCP_MODE_CONFIG_MISMATCH',
            message: 'Manual parameter config mode requires parameterValues to be configured',
            field: `nodes[${node.id}].data.parameterValues`,
          });
        }
      }
      break;

    case 'aiParameterConfig':
      // AI parameter config mode requires toolName, toolDescription, parameters, aiParameterConfig
      if (!mcpData.toolName || mcpData.toolName.trim().length === 0) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'AI parameter config mode requires toolName to be set',
          field: `nodes[${node.id}].data.toolName`,
        });
      }
      if (!mcpData.toolDescription || mcpData.toolDescription.trim().length === 0) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'AI parameter config mode requires toolDescription to be set',
          field: `nodes[${node.id}].data.toolDescription`,
        });
      }
      if (!mcpData.parameters || mcpData.parameters.length === 0) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'AI parameter config mode requires parameters array to be set',
          field: `nodes[${node.id}].data.parameters`,
        });
      }
      if (!mcpData.aiParameterConfig) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'AI parameter config mode requires aiParameterConfig to be set',
          field: `nodes[${node.id}].data.aiParameterConfig`,
        });
      } else if (
        !mcpData.aiParameterConfig.description ||
        mcpData.aiParameterConfig.description.trim().length === 0
      ) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message:
            'AI parameter config mode requires aiParameterConfig.description to be non-empty',
          field: `nodes[${node.id}].data.aiParameterConfig.description`,
        });
      }
      // parameterValues is optional (AI will set values based on description)
      break;

    case 'aiToolSelection':
      // AI tool selection mode requires aiToolSelectionConfig
      if (!mcpData.aiToolSelectionConfig) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message: 'AI tool selection mode requires aiToolSelectionConfig to be set',
          field: `nodes[${node.id}].data.aiToolSelectionConfig`,
        });
      } else if (
        !mcpData.aiToolSelectionConfig.taskDescription ||
        mcpData.aiToolSelectionConfig.taskDescription.trim().length === 0
      ) {
        errors.push({
          code: 'MCP_MODE_CONFIG_MISMATCH',
          message:
            'AI tool selection mode requires aiToolSelectionConfig.taskDescription to be non-empty',
          field: `nodes[${node.id}].data.aiToolSelectionConfig.taskDescription`,
        });
      }
      // toolName is optional for AI tool selection mode (AI will select the tool)
      break;

    default:
      // Unknown mode
      errors.push({
        code: 'MCP_INVALID_MODE',
        message: `Invalid MCP mode: ${mode}. Must be one of: manualParameterConfig, aiParameterConfig, aiToolSelection`,
        field: `nodes[${node.id}].data.mode`,
      });
  }

  return errors;
}

/**
 * Validate all connections in the workflow
 */
function validateConnections(connections: Connection[], nodes: WorkflowNode[]): ValidationError[] {
  const errors: ValidationError[] = [];
  const nodeIds = new Set(nodes.map((n) => n.id));
  const connectionIds = new Set<string>();

  for (const conn of connections) {
    // Check for duplicate connection IDs
    if (connectionIds.has(conn.id)) {
      errors.push({
        code: 'DUPLICATE_CONNECTION_ID',
        message: `Duplicate connection ID: ${conn.id}`,
        field: `connections[${conn.id}]`,
      });
    }
    connectionIds.add(conn.id);

    // Validate from/to node IDs exist
    if (!nodeIds.has(conn.from)) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: `Connection references non-existent from node: ${conn.from}`,
        field: `connections[${conn.id}].from`,
      });
    }

    if (!nodeIds.has(conn.to)) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: `Connection references non-existent to node: ${conn.to}`,
        field: `connections[${conn.id}].to`,
      });
    }

    // Validate no self-connections
    if (conn.from === conn.to) {
      errors.push({
        code: 'SELF_CONNECTION',
        message: 'Node cannot connect to itself',
        field: `connections[${conn.id}]`,
      });
    }

    // Validate Start/End node connection rules
    const fromNode = nodes.find((n) => n.id === conn.from);
    const toNode = nodes.find((n) => n.id === conn.to);

    if (toNode?.type === NodeType.Start) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: 'Start node cannot have input connections',
        field: `connections[${conn.id}]`,
      });
    }

    if (fromNode?.type === NodeType.End) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: 'End node cannot have output connections',
        field: `connections[${conn.id}]`,
      });
    }
  }

  // Check for cycles (simplified check - full cycle detection would be more complex)
  // For MVP, we'll rely on the AI to generate acyclic workflows

  return errors;
}

/**
 * Validate hooks configuration
 *
 * Issue #413: Hooks configuration for workflow execution
 * See: https://code.claude.com/docs/en/hooks
 *
 * @param hooks - Hooks configuration to validate
 * @returns Array of validation errors
 */
function validateHooks(hooks: WorkflowHooks): ValidationError[] {
  const errors: ValidationError[] = [];

  const validHookTypes: HookType[] = ['PreToolUse', 'PostToolUse', 'Stop'];
  const validActionTypes = ['command', 'prompt'];

  for (const [hookType, entries] of Object.entries(hooks)) {
    // Validate hook type
    if (!validHookTypes.includes(hookType as HookType)) {
      errors.push({
        code: 'HOOKS_INVALID_TYPE',
        message: `Invalid hook type: ${hookType}. Must be one of: ${validHookTypes.join(', ')}`,
        field: `hooks.${hookType}`,
      });
      continue;
    }

    // Validate entries array
    if (!Array.isArray(entries)) {
      errors.push({
        code: 'HOOKS_INVALID_ENTRIES',
        message: `Hook ${hookType} entries must be an array`,
        field: `hooks.${hookType}`,
      });
      continue;
    }

    // Validate max entries per hook
    if (entries.length > VALIDATION_RULES.HOOKS.MAX_ENTRIES_PER_HOOK) {
      errors.push({
        code: 'HOOKS_TOO_MANY_ENTRIES',
        message: `Hook ${hookType} exceeds maximum of ${VALIDATION_RULES.HOOKS.MAX_ENTRIES_PER_HOOK} entries`,
        field: `hooks.${hookType}`,
      });
    }

    // Validate each entry
    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];

      if (!entry || typeof entry !== 'object') {
        errors.push({
          code: 'HOOKS_INVALID_ENTRY',
          message: `Hook ${hookType}[${i}] must be an object`,
          field: `hooks.${hookType}[${i}]`,
        });
        continue;
      }

      // Validate matcher (optional for all hook types, but check length if provided)
      if (entry.matcher) {
        if (typeof entry.matcher !== 'string') {
          errors.push({
            code: 'HOOKS_INVALID_MATCHER',
            message: `Hook ${hookType}[${i}] matcher must be a string`,
            field: `hooks.${hookType}[${i}].matcher`,
          });
        } else if (entry.matcher.length > VALIDATION_RULES.HOOKS.MATCHER_MAX_LENGTH) {
          errors.push({
            code: 'HOOKS_MATCHER_TOO_LONG',
            message: `Hook ${hookType}[${i}] matcher exceeds ${VALIDATION_RULES.HOOKS.MATCHER_MAX_LENGTH} characters`,
            field: `hooks.${hookType}[${i}].matcher`,
          });
        }
      }

      // Validate hooks array (actions)
      if (!entry.hooks || !Array.isArray(entry.hooks)) {
        errors.push({
          code: 'HOOKS_MISSING_ACTIONS',
          message: `Hook ${hookType}[${i}] must have a hooks array`,
          field: `hooks.${hookType}[${i}].hooks`,
        });
        continue;
      }

      if (entry.hooks.length === 0) {
        errors.push({
          code: 'HOOKS_EMPTY_ACTIONS',
          message: `Hook ${hookType}[${i}].hooks cannot be empty`,
          field: `hooks.${hookType}[${i}].hooks`,
        });
      }

      if (entry.hooks.length > VALIDATION_RULES.HOOKS.MAX_ACTIONS_PER_ENTRY) {
        errors.push({
          code: 'HOOKS_TOO_MANY_ACTIONS',
          message: `Hook ${hookType}[${i}].hooks exceeds maximum of ${VALIDATION_RULES.HOOKS.MAX_ACTIONS_PER_ENTRY} actions`,
          field: `hooks.${hookType}[${i}].hooks`,
        });
      }

      // Validate each action
      for (let j = 0; j < entry.hooks.length; j++) {
        const action = entry.hooks[j];

        if (!action || typeof action !== 'object') {
          errors.push({
            code: 'HOOKS_INVALID_ACTION',
            message: `Hook ${hookType}[${i}].hooks[${j}] must be an object`,
            field: `hooks.${hookType}[${i}].hooks[${j}]`,
          });
          continue;
        }

        // Validate action type
        if (!action.type || !validActionTypes.includes(action.type)) {
          errors.push({
            code: 'HOOKS_INVALID_ACTION_TYPE',
            message: `Hook ${hookType}[${i}].hooks[${j}].type must be one of: ${validActionTypes.join(', ')}`,
            field: `hooks.${hookType}[${i}].hooks[${j}].type`,
          });
        }

        // Validate command (required for type: 'command')
        if (action.type === 'command') {
          if (!action.command || typeof action.command !== 'string') {
            errors.push({
              code: 'HOOKS_MISSING_COMMAND',
              message: `Hook ${hookType}[${i}].hooks[${j}] requires a command string`,
              field: `hooks.${hookType}[${i}].hooks[${j}].command`,
            });
          } else {
            // Validate command length
            if (action.command.length < VALIDATION_RULES.HOOKS.COMMAND_MIN_LENGTH) {
              errors.push({
                code: 'HOOKS_COMMAND_EMPTY',
                message: `Hook ${hookType}[${i}].hooks[${j}].command cannot be empty`,
                field: `hooks.${hookType}[${i}].hooks[${j}].command`,
              });
            }

            if (action.command.length > VALIDATION_RULES.HOOKS.COMMAND_MAX_LENGTH) {
              errors.push({
                code: 'HOOKS_COMMAND_TOO_LONG',
                message: `Hook ${hookType}[${i}].hooks[${j}].command exceeds ${VALIDATION_RULES.HOOKS.COMMAND_MAX_LENGTH} characters`,
                field: `hooks.${hookType}[${i}].hooks[${j}].command`,
              });
            }
          }
        }

        // Validate once (optional boolean)
        if (action.once !== undefined && typeof action.once !== 'boolean') {
          errors.push({
            code: 'HOOKS_INVALID_ONCE',
            message: `Hook ${hookType}[${i}].hooks[${j}].once must be a boolean`,
            field: `hooks.${hookType}[${i}].hooks[${j}].once`,
          });
        }
      }
    }
  }

  return errors;
}
